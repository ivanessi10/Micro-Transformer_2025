def terra_prompt(premise: str, hypothesis: str) -> str:
    return f"""
Ты решаешь задачу логического вывода (NLI).
Прочитай два предложения и определи, следует ли гипотеза из текста.

Формат ответа: "entailment" или "not_entailment".

Текст: {premise}
Гипотеза: {hypothesis}

Ответ:
"""


def parus_prompt(
        premise: str,
        choice1: str,
        choice2: str,
        question: str) -> str:
    direction = "причина" if question == "cause" else "следствие"
    return f"""
Дана текстовая ситуация {premise} и два текста-
продолжения: 1) {choice1}, 2) {choice2}.
Определи, какой из двух фрагментов является {direction}
описанной ситуации.
В качестве ответа выведи одну цифру 1 или 2.
"""


def lidirus_prompt(
        sentence1: str,
        sentence2: str,
        knowledge: str,
        lexical_semantics: str,
        logic: str,
        predicate_argument_structure: str
        ) -> str:
    return f"""
Ты решаешь задачу на лингвистическую диагностику
русского языка. Тебе даны:
1) Первое предложение: {sentence1},
2) Второе предложение: {sentence2},
3) Признак, связанный с фактуальными знаниями
(например, требует ли задача понимания реального мира) {knowledge}.
4) Отношение к лексической семантике
{lexical_semantics}.
5)Логическая связь между предложениями: {logic}.
6)Синтаксическая структура:
{predicate_argument_structure}

Только один из этих параметров непустой.
В зависимости от этого тебе нужно определить
правильно ли соотносятся предложения.

Например:
первое предложение: Кошка сидела на коврике.
второе предложение: Кошка не сидела на коврике.
Логическая связь: negation. Остальные признаки пустые.
Ответом будет 1, так как предложения действительно противоречат друг другу.

Формат ответа: 0(если неправильно) или 1(если правильно).
Ответ:
"""


def danetqa_prompt(text: str, question: str) -> str:
    return f"""
Ты решаешь задачу бинарного ответа на вопрос по тексту.
Дан текст и вопрос. Ответ должен быть "да" или "нет" и должен вытекать
из содержания текста.

Формат ответа: "да" или "нет".

Текст: {text}
Вопрос: {question}

Ответ:
"""


def russe_wic_prompt(word: str, sentence1: str, sentence2: str) -> str:
    return f"""
Ты решаешь задачу дизамбигуации слова по контексту (Word-in-Context).
Дано слово и два предложения, где оно используется.
Нужно определить, используется ли слово в одном и том же значении в обоих
предложениях.

Формат ответа: 1 (если значение одно и то же) или 0 (если значения
различаются).

Слово: {word}
Предложение 1: {sentence1}
Предложение 2: {sentence2}

Ответ:
"""


def rcb_prompt(premise: str, hypothesis: str, negation: str, verb: str):
    return f"""
Тебе дан текст и гипотеза. Нужно определить их логическое соотношение,
выбери один из трёх вариантов ответа:
0 - гипотеза следует из текста,
1 - гипотеза не противоречит, но и не подтверждается,\
2 - гипотеза противоречит посылке.
Формат ответа: одно число.

Текст: {premise}
Гипотеза: {hypothesis}
Наличие отрицания: {negation}
Глагол действия, по которому подбирались тексты: {verb}

Ответ:
"""


def muserc_prompt(text: str, question: str, answer: str):
    return f"""
Внимательно прочитай текст: {text}. Тебе даны: вопрос: {question},
и ответ: {answer}.
Определи, является ли ответ на вопрос правильным.
Формат ответа: 0 - если ответ неверен, 1 - если ответ верен.

Ты решаешь задачу бинарной классификации.
На основе данного текста нужно ответить на несколько вопросов, каждый из
которых сопровождается вариантами ответа.

Формат ответа: 0 - если ответ неверен, 1 - если ответ верен.
Укажи номера всех правильных вариантов (через запятую, если их несколько).


"""


def rwsd_prompt(text: str, span1: str, span2: str) -> str:
    return f"""
Ты решаешь задачу разрешения кореференции.
Прочитай предложение и определи, обозначают ли выделенные фразы один и тот
же объект.

Формат ответа: "true" или "false".

Предложение: {text}
Фраза 1: {span1}
Фраза 2: {span2}

Ответ:
"""


def rucos_prompt(passage: str, query: str, entities) -> str:
    return f"""
Ты решаешь задачу восстановления пропуска в тексте.
Прочитай текст: {passage} и вставь на место "@placeholder"
в запросе: {query} - подходящий
вариант из списка {entities}, исходя из
контекста.

Формат ответа: конкретное слово или фраза.

Текст: {passage}
Вопрос: {query}

Ответ:
"""
